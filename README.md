# dumb-down-react

## Concurrent Mode
리액트는 자바스크립트 기반이기 때문에 싱글 스레드이다. 그러나 Concurrent Mode를 이용하면 여러 작업을 동시에 처리할 수 있다. 리액트는 UI 렌더링 도중에 렌더링 이외의 모든 작업을 중단한다.
동시성은 여러 작업을 작은 단위로 나눈 뒤, 그들 간의 우선 순위를 정하고 그에 따라 작업을 번갈아 수행하는 방법이다. 실제로 작업이 동시에 이루어지는 것은 아니지만 작업 간 전환이 매우 빠르게 일어나기 때문에 동시에 작업되는 것처럼 보이는 것이다.

### 필요
1. 기존 디바운스와 스로틀의 한계
> 문제 1: 사용자가 input을 입력할 때마다 무거운 작업을 수행하는 경우
> 문제 2: 응답을 받는 데 시간이 걸리는 네트워크 요청
> 문제 3: 많은 DOM element 생성

문제를 해결하기 위해 디바운스와 스로틀을 사용했는데, 한계가 있다.
#### 디바운스
디바운스는 사용자의 마지막 입력이 끝난 뒤 일정 시간이 지나면 무거운 작업을 수행하는 방법이다. 이 방법은 기기의 성능과 관계 없이 무조건 일정 시간을 기다려야 한다는 단점이 있다. 성능이 좋을 수록 손해다. 또 사용자 입력 중에 무거운 작업의 처리가 이루어지지 않는다는 점도 아쉽다.
#### 스로틀
디바운스에서 입력 중 무거운 작업의 처리가 이루어지지 않는 점은 스로틀로 개선할 수 있다. 스로틀은 입력 중에 주기적으로 무거운 작업을 수행하는 방법이다. 스로틀 주기를 짧게 가져갈 수록 성능이 좋은 기기에서는 사용자 경험을 높일 수 있으나 성능이 나쁜 기기에서는 버벅거림이 심해질 뿐이다.

Concurrent Mode는 디바운스와 스로틀의 한계를 동시성으로 해결한다. 작업간 전환이 빠르기 때문에 사용자의 입력과 무거운 작업이 동시에 처리될 수 있다. 작업 처리 속도는 개발자가 설정한 delay 타임에 의존하는 것이 아니라 사용자의 기기 성능에 의존한다.

2. 충분히 렌더링이 빠른데 의미없는 로딩을 보여주는 경우
Suspense로만 구현된 로딩은 이전 페이지를 유저로부터 차단하고, 다음 페이지의 전체 로딩 화면으로 대체하므로 유저 경험이 좋지 않다. 가끔은 로딩 UI가 아주 빠르게 나타났다가 사라지기도 한다.
이를 Concurrent Mode는 일정 시간동안 현재 페이지의 기능을 유지하고, 동시에 다음 페이지에 대한 렌더링을 진행하는 방식으로 문제를 해결한다. 다음 페이지의 렌더링 단계가 특정 조건에 부합하면 해당 페이지를 렌더링한다.

### 동작 원리
> 특정 state가 변경되었을 때 **현재 UI를 유지**하고, 변경에 따른 UI 업데이트를 동시에 준비.
> 준비 중인 UI의 **렌더링 단계**가 **특정 조건**에 부합하면 이를 실제 DOM에 반영.

#### 렌더링 단계
1. Transition: state 변경 직후에 일어날 수 있는 UI 렌더링 단계.
   2. Pending 상태: 리액트에서 제공하는 useTransition 훅을 사용하면 state 변경 직후에도 UI를 업데이트하지 않고 현 UI를 잠시 유지할 수 있다. 이를 Pending 상태라고 한다. 
   3. Receded 상태: useTransition 훅을 사용하지 않은 긱본 상태. state 변경 직후 UI가 변경된다. 전체 페이지에 대한 로딩 화면이라고 생각하면 이해하기 쉽다. Pending 상태에서도 Receded 상태로 넘어갈 수 있는데 Pending 상태의 시간이 useTransition 옵션으로 지정된 timeoutMs를 넘으면 강제로 Receded 상태가 된다.
2. Loading: Skeleton 상태 페이지의 일부만을 로딩하는 상태. 전체 화면을 모두 로딩으로 대체하는 Receded와 다르다.
3. Done: Complete 상태로 로딩 UI 없이 모든 정보가 사용자에게 보이는 상태

#### 특정 조건
> 특정 state 변경에 대한 현 화면의 UI 렌더링 단계보다 더 최신 단계로 진행해야 실제 DOM에 반영된다.


## Fibers
작업 단위를 설정하려면 일종의 섬유 트리. 자료 구조가 필요하다.
```javascript
render(
  <div>
    <h1>
      <p />
      <a />
    </h1>
    <h2 />
  </div>,
  container
)
```
위 트리를 렌더한다고 가정하면, 렌더 과정에서 root fiber를 생성하고, 이를 다음 작업 단위로 설정한다. 나머지 작업은 doNextWork 함수에서 수핸되고, 여기에서 각 섬유에 대한 세 가지 작업을 진행한다.
1. 요소를 DOM에 추가한다.
2. 그 요소의 child를 위한 섬유를 만든다.
3. 다음 작업 단위를 선택한다.

이 데이터 구조(섬유 트리)의 목표는 다음 작업 단위를 쉽게 찾을 수 있도록 하는 것이다. 그래서 이들은 트리 구조로 각 섬유가 첫 번째 children, next sibling, parent와 연결되어 있다. 원래 목적이 그럼.
한 섬유에 대한 작업이 끝났을 때 이 섬유가 children을 가지고 있다면 그 섬유 다음 작업 범위는 children이다. <div> fiber에 대한 작업을 진행했다면 다음은 <h1> fiber다.
섬유와 연결된 child가 없다면 sibling으로 넘어간다. <p> 섬유는 child가 없기 때문에 <a>로 넘어간다.
섬유에 child나 sibling이 없다면 parent로 넘어간다. 부모의 형제를 탐색하기 시작한다. <a>가 가진 자식도, 작업할 형제도 남아있지 않기 때문에 다시 <h1>으로 돌아가 그의 형제를 찾는다. <h2>가 다음 작업이 된다.
부모 역시 sibling이 없다면 있는 섬유를 찾아 올라간다. root에 도달할 때까지 이 작업을 반복한다. root에 도달했다면 모든 렌더가 종료되었음을 의미한다.


